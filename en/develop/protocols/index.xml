<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>协议详解 on Project X</title><link>https://xtls.github.io/en/develop/protocols/</link><description>Recent content in 协议详解 on Project X</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Wed, 23 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://xtls.github.io/en/develop/protocols/index.xml" rel="self" type="application/rss+xml"/><item><title>VLESS 协议</title><link>https://xtls.github.io/en/develop/protocols/vless/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/protocols/vless/</guid><description>VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。
In progress</description></item><item><title>VMess 协议</title><link>https://xtls.github.io/en/develop/protocols/vmess/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/protocols/vmess/</guid><description>VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。
版本 当前版本号为 1。
依赖 底层协议 VMess 是一个基于 TCP 的协议，所有数据使用 TCP 传输。
用户 ID ID 等价于 UUID，是一个 16 字节长的随机数，它的作用相当于一个令牌（Token）。 一个 ID 形如：de305d54-75b4-431b-adb2-eb6b9e546014，几乎完全随机，可以使用任何的 UUID 生成器来生成，比如这个。
用户 ID 可在配置文件中指定。
函数 MD5: MD5 函数 输入参数为任意长度的 byte 数组 输出为一个 16 byte 的数组 HMAC: HMAC 函数 输入参数为： H：散列函数 K：密钥，任意长度的 byte 数组 M：消息，任意长度的 byte 数组 Shake: SHA3-Shake128 函数 输入参数为任意长度的字符串 输出为任意长度的字符串</description></item><item><title>Mux.Cool 协议</title><link>https://xtls.github.io/en/develop/protocols/muxcool/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/protocols/muxcool/</guid><description>Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。
版本 当前版本是 1 Beta。
依赖 底层协议 Mux.Cool 必须运行在一个已建立的可靠数据流之上。
通讯过程 一个 Mux.Cool 连接中可传输若干个子连接，每个子连接有一个独立的 ID 和状态。传输过程由帧（Frame）组成，每一帧用于传输一个特定的子连接的数据。
客户端行为 当有连接需求时并且没有现有可用的连接时，客户端向服务器发起一个新连接，以下称为“主连接”。
一个主连接可用于发送若干个子连接。客户端可自主决定主连接可承载的子连接数量。 对于一个新的子连接，客户端必须发送状态New以通知服务器建立子连接，然后使用状态Keep来传送数据。 当子连接结束时，客户端发送End状态来通知服务器关闭子连接。 客户端可自行决定何时关闭主连接，但必须确定服务器也同时保持连接。 客户端可使用 KeepAlive 状态来避免服务器关闭主连接。
服务器端行为 当服务器端接收到新的子连接时，服务器应当按正常的连接来处理。
当收到状态End时，服务器端可以关闭对目标地址的上行连接。 在服务器的响应中，必须使用与请求相同的 ID 来传输子连接的数据。 服务器不能使用New状态。 服务器可使用 KeepAlive 状态来避免客户端关闭主连接。
传输格式 Mux.Cool 使用对称传输格式，即客户端和服务器发送和接收相同格式的数据。
帧格式 2 字节 L 字节 X 字节 元数据长度 L 元数据 额外数据</description></item><item><title>mKCP 协议</title><link>https://xtls.github.io/en/develop/protocols/mkcp/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/protocols/mkcp/</guid><description>mKCP 是流式传输协议，由 KCP 协议修改而来，可以按顺序传输任意的数据流。
版本 mKCP 没有版本号，不保证版本之间兼容性。
依赖 底层协议 mKCP 是一个基于 UDP 的协议，所有通讯使用 UDP 传输。
函数 fnv: FNV-1a 哈希函数 输入参数为任意长度的字符串； 输入出一个 32 位无符号整数；
通讯过程 mKCP 将数据流拆成若干个数据包进行发送。一个数据流有一个唯一标识，用以区分不同的数据流。数据流中的每一个数据包都携带了同样的标识。 mKCP 没有握手过程，当收到一个数据包时，根据其携带的数据流的标识来判断是否为新的通话，或是正在进行中的通话。 每一个数据包中包含若干个片段（Segment），片段分为三类：数据（Data）、确认（ACK）、心跳（Ping）。每个片段需要单独处理。
数据格式 数据包 4 字节 2 字节 L 字节 认证信息 A 数据长度 L 片段部分 其中：</description></item></channel></rss>