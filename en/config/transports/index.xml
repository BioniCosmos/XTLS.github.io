<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>传输方式列表 on Project X</title><link>https://xtls.github.io/en/config/transports/</link><description>Recent content in 传输方式列表 on Project X</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Wed, 23 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://xtls.github.io/en/config/transports/index.xml" rel="self" type="application/rss+xml"/><item><title>TCP</title><link>https://xtls.github.io/en/config/transports/tcp/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/tcp/</guid><description>TCP 传输模式是目前推荐使用的传输模式之一.
可以和各种协议有多种组合模式.
TcpObject TcpObject 对应传输配置的 tcpSettings 项。
{ &amp;#34;acceptProxyProtocol&amp;#34;: false, &amp;#34;header&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;none&amp;#34; } } acceptProxyProtocol: true | false
仅用于 inbound，指示是否接收 PROXY protocol。
PROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。
常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。
填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。
默认值为 false。
header: NoneHeaderObject | HttpHeaderobject
数据包头部伪装设置，默认值为 NoneHeaderObject。
TIP
HTTP 伪装无法被其它 HTTP 服务器（如 Nginx）分流，但可以被 VLESS fallbacks path 分流。
NoneHeaderObject 不进行伪装</description></item><item><title>WebSocket</title><link>https://xtls.github.io/en/config/transports/websocket/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/websocket/</guid><description>使用标准的 WebSocket 来传输数据。
WebSocket 连接可以被其它 HTTP 服务器（如 Nginx）分流，也可以被 VLESS fallbacks path 分流。
TIP
Websocket 会识别 HTTP 请求的 X-Forwarded-For 头来覆写流量的源地址，优先级高于 PROXY protocol。
WebSocketObject WebSocketObject 对应传输配置的 wsSettings 项。
{ &amp;#34;acceptProxyProtocol&amp;#34;: false, &amp;#34;path&amp;#34;: &amp;#34;/&amp;#34;, &amp;#34;headers&amp;#34;: { &amp;#34;Host&amp;#34;: &amp;#34;xray.com&amp;#34; } } acceptProxyProtocol: true | false
仅用于 inbound，指示是否接收 PROXY protocol。
PROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。
常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。
填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。
path string</description></item><item><title>Domain Socket</title><link>https://xtls.github.io/en/config/transports/domainsocket/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/domainsocket/</guid><description>important推荐写到 inbounds 的 listen 处，传输方式可选 TCP、WebSocket、HTTP/2.
未来这里的 DomainSocket 可能会被弃用。
Domain Socket 使用标准的 Unix domain socket 来传输数据。
它的优势是使用了操作系统内建的传输通道，而不会占用网络缓存。 理论上相比起本地环回网络（local loopback）来说，Domain socket 速度略快一些。
目前仅可用于支持 Unix domain socket 的平台，如 Linux 和 macOS。在 Windows 10 Build 17036 前不可用。
如果指定了 domain socket 作为传输方式，在入站出站代理中配置的端口和 IP 地址将会失效，所有的传输由 domain socket 取代。
DomainSocketObject DomainSocketObject 对应传输配置的 dsSettings 项。
{ &amp;#34;path&amp;#34;: &amp;#34;/path/to/ds/file&amp;#34;, &amp;#34;abstract&amp;#34;: false, &amp;#34;padding&amp;#34;: false } path: string
一个合法的文件路径。 important在运行 Xray 之前，这个文件必须不存在。
abstract: true | false</description></item><item><title>mKCP</title><link>https://xtls.github.io/en/config/transports/mkcp/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/mkcp/</guid><description>mKCP 使用 UDP 来模拟 TCP 连接。
mKCP 牺牲带宽来降低延迟。传输同样的内容，mKCP 一般比 TCP 消耗更多的流量。
TIP
请确定主机上的防火墙配置正确
KcpObject KcpObject 对应传输配置的 kcpSettings 项。
{ &amp;#34;mtu&amp;#34;: 1350, &amp;#34;tti&amp;#34;: 20, &amp;#34;uplinkCapacity&amp;#34;: 5, &amp;#34;downlinkCapacity&amp;#34;: 20, &amp;#34;congestion&amp;#34;: false, &amp;#34;readBufferSize&amp;#34;: 1, &amp;#34;writeBufferSize&amp;#34;: 1, &amp;#34;header&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;none&amp;#34; }, &amp;#34;seed&amp;#34;: &amp;#34;Password&amp;#34; } mtu: number
最大传输单元（maximum transmission unit）
请选择一个介于 576 - 1460 之间的值。
默认值为 1350。
tti: number
传输时间间隔（transmission time interval），单位毫秒（ms），mKCP 将以这个时间频率发送数据。
请选译一个介于 10 - 100 之间的值。
默认值为 50。</description></item><item><title>HTTP/2</title><link>https://xtls.github.io/en/config/transports/h2/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/h2/</guid><description>基于 HTTP/2 的传输方式。
它完整按照 HTTP/2 标准实现，可以通过其它的 HTTP 服务器（如 Nginx）进行中转。
由 HTTP/2 的建议，客户端和服务器必须同时开启 TLS 才可以正常使用这个传输方式。
TIP
当前版本的 HTTP/2 的传输方式并不强制要求服务器端有 TLS 配置.
这使得可以在特殊用途的分流部署环境中，由外部网关组件完成 TLS 层对话，Xray 作为后端应用，网关和 Xray 间使用称为 h2c 的明文 http/2 进行通讯。
HttpObject HttpObject 对应传输配置的 httpSettings 项。
{ &amp;#34;host&amp;#34;: [&amp;#34;xray.com&amp;#34;], &amp;#34;path&amp;#34;: &amp;#34;/random/path&amp;#34; } host: [string]
一个字符串数组，每一个元素是一个域名。
客户端会随机从列表中选出一个域名进行通信，服务器会验证域名是否在列表中。
path string
HTTP 路径，由 / 开头, 客户端和服务器必须一致。
默认值为 &amp;quot;/&amp;quot;。</description></item><item><title>QUIC</title><link>https://xtls.github.io/en/config/transports/quic/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/quic/</guid><description>QUIC 全称 Quick UDP Internet Connection，是由 Google 提出的使用 UDP 进行多路并发传输的协议。其主要优势是:
减少了握手的延迟（1-RTT 或 0-RTT） 多路复用，并且没有 TCP 的阻塞问题 连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开。 QUIC 目前处于实验期，使用了正在标准化过程中的 IETF 实现，不能保证与最终版本的兼容性。
默认设定: 12 字节的 Connection ID 30 秒没有数据通过时自动断开连接 (可能会影响一些长连接的使用) QuicObject QuicObject 对应传输配置的 quicSettings 项。
important对接的两端的配置必须完全一致，否则连接失败。 QUIC 强制要求开启 TLS，在传输配置中没有开启 TLS 时，Xray 会自行签发一个证书进行 TLS 通讯。
{ &amp;#34;security&amp;#34;: &amp;#34;none&amp;#34;, &amp;#34;key&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;header&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;none&amp;#34; } } security: &amp;ldquo;none&amp;rdquo; | &amp;ldquo;aes-128-gcm&amp;rdquo; | &amp;ldquo;chacha20-poly1305&amp;rdquo;</description></item></channel></rss>